"""
FiftyOne Server /media route

| Copyright 2017-2024, Voxel51, Inc.
| `voxel51.com <https://voxel51.com/>`_
|
"""
import os
import typing as t

import anyio
import aiofiles
from aiofiles.threadpool.binary import AsyncBufferedReader
from aiofiles.os import stat as aio_stat
from starlette.endpoints import HTTPEndpoint
from starlette.requests import Request
from starlette.responses import (
    FileResponse,
    Response,
    StreamingResponse,
    guess_type,
)

import logging

logger = logging.getLogger("fiftyone.server.routes.media")

# Example usage within your functions
logger.debug("Debug message example")
logger.info("Info message example")
logger.error("Error message example")

file_handler = logging.FileHandler('fiftyone_media.txt')
file_handler.setLevel(logging.DEBUG)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)

# Create a handler to display the logs on the console
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Add the handlers to the logger
logger.addHandler(file_handler)
logger.addHandler(console_handler)

logger.info("Starting FiftyOne media...")

import boto3
from botocore.exceptions import BotoCoreError, NoCredentialsError, PartialCredentialsError,ClientError
import urllib.parse as up

s3 = boto3.client(
    's3',
    endpoint_url="http://localhost:9000",
    aws_access_key_id ="minio_access_key",
    aws_secret_access_key = "minio_secret_key",
    region_name="us-east-1"
)

async def ranged(
    file: AsyncBufferedReader,
    start: int = 0,
    end: int = None,
    block_size: int = 8192,
) -> t.AsyncGenerator:
    consumed = 0

    await file.seek(start)

    while True:
        data_length = (
            min(block_size, end - start - consumed) if end else block_size
        )

        if data_length <= 0:
            break

        data = await file.read(data_length)

        if not data:
            break

        consumed += data_length

        yield data

    if hasattr(file, "close"):
        await file.close()


class Media(HTTPEndpoint):
    async def get(
        self, request: Request
    ) -> t.Union[FileResponse, StreamingResponse]:
        path = request.query_params.get("filepath")
        checked_path = up.unquote(path)
        if "s3://" in checked_path:
            logger.info(f"Handling S3 request for filepath: {path}")
            return await self.get_s3_path(path)
        
        logger.info(f"Handling local file request for path: {path}")

        response: t.Union[FileResponse, StreamingResponse]

        try:
            await anyio.to_thread.run_sync(os.stat, path)
        except FileNotFoundError:
            logger.error(f"File not found: {path}")
            return Response(content="Not found", status_code=404)

        # Handle range request
        if request.headers.get("range"):
            logger.info(f"Handling range request for file: {path}")
            response = await self.ranged_file_response(path, request)
        else:
            logger.info(f"Serving full file: {path}")
            response = FileResponse(path)

        response.headers["Accept-Ranges"] = "bytes"
        return response
    
    async def get_s3_path(
        self, url
    ) -> t.Union[FileResponse, StreamingResponse]:
        logger.info(f"At get_s3_path, the url is {url}" )
        bucket_name, key = url.replace("s3://", "").split("/", 1)
        response: t.Union[FileResponse, StreamingResponse]
        try:
            result = s3.get_object(Bucket=bucket_name, Key=key)
            headers = self.create_custom_s3_headers(result)

            response = StreamingResponse(
               content=result['Body'],
               headers=headers
            )

        except ClientError as e:
            error_code = e.response['Error']['Code']
            
            if error_code == 'NoSuchKey':
                return Response(content="File not found", status_code=404)
            elif error_code == 'NoSuchBucket':
                return Response(content="Bucket not found", status_code=404)
            else:
                return Response(content="S3 Client Error", status_code=500)

        except (NoCredentialsError, PartialCredentialsError) as e:
            return Response(content="S3 Credentials Error", status_code=403)

        except BotoCoreError as e:
            return Response(content="S3 BotoCore Error", status_code=500)

        except Exception as e:
            return Response(content="Unexpected Error", status_code=500)
        return response
    
    def create_custom_s3_headers(self,s3_response):
        headers = s3_response['ResponseMetadata']['HTTPHeaders']
        return headers
 
    async def ranged_file_response(
        self, path: str, request: Request
    ) -> StreamingResponse:
        file = await aiofiles.open(path, "rb")
        file_size = (await aio_stat(path)).st_size
        content_range = request.headers.get("range")
        content_length = file_size
        status_code = 200
        headers = {}

        if content_range is not None:
            content_range = content_range.strip().lower()

            content_ranges = content_range.split("=")[-1]

            range_start, range_end, *_ = map(
                str.strip, (content_ranges + "-").split("-")
            )

            start, end = (
                int(range_start) if range_start else 0,
                int(range_end) if range_end else file_size - 1,
            )
            range_start = max(0, start)
            range_end = min(file_size - 1, int(end))

            content_length = (end - start) + 1

            file_response = ranged(file, start=start, end=end + 1)

            status_code = 206

            headers["Content-Range"] = f"bytes {start}-{end}/{file_size}"

        response = StreamingResponse(
            file_response,
            media_type=guess_type(path)[0],
            status_code=status_code,
        )

        response.headers.update(
            {
                "Accept-Ranges": "bytes",
                "Content-Length": str(content_length),
                **headers,
            }
        )

        return response
    
    async def head(self, request: Request) -> Response:
        path = request.query_params["filepath"]
        response = Response()
        size = (await aio_stat(path)).st_size
        response.headers.update(
            {
                "Accept-Ranges": "bytes",
                "Content-Type": guess_type(path)[0],
                "Content-Length": size,
            }
        )
        return response

    async def options(self, request: Request) -> Response:
        response = Response()
        response.headers["Accept-Ranges"] = "bytes"
        response.headers["Allow"] = "OPTIONS, GET, HEAD"
        return response
